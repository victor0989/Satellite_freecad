# -*- coding: utf-8 -*-
# Parametric satellite assembly — FreeCAD Python API
# Versión ampliada: materiales ultraduraderos, envolvente exterior imprimible,
# cascarón cerrando huecos, compartimentos internos y volúmenes.
# Unidades en metros.

import FreeCAD as App
import Part
import MeshPart
import math
from FreeCAD import Vector

DOC_NAME = "Satellite_Param"

def new_doc(name):
    doc = App.newDocument(name) if App.ActiveDocument is None else App.ActiveDocument
    if doc.Name != name:
        doc = App.newDocument(name)
    return doc

doc = new_doc(DOC_NAME)

# -----------------------
# Materials (incluye 'ultra' durables)
# -----------------------
MATERIALS = {
    "Al6061":      {"rho":2700.0, "alpha":0.2, "eps":0.8, "t_nom":0.002},
    "Al2219":      {"rho":2840.0, "alpha":0.15, "eps":0.08, "t_nom":0.002},
    "Ti":          {"rho":4430.0, "alpha":0.2, "eps":0.8, "t_nom":0.003},
    "Ti_Al":       {"rho":4400.0, "alpha":0.3, "eps":0.7, "t_nom":0.004},
    "CFRP":        {"rho":1600.0, "alpha":0.15, "eps":0.05, "t_nom":0.002},
    "UltraAlloy":  {"rho":8000.0, "alpha":0.12, "eps":0.06, "t_nom":0.006},  # material "ultraduro"
    "MLI":         {"rho":1400.0, "alpha":0.05, "eps":0.85, "t_nom":0.005},
    "Panel_CFRP":  {"rho":550.0, "alpha":0.2, "eps":0.8, "t_nom":0.02},
    "Radiator":    {"rho":120.0, "alpha":0.15, "eps":0.85, "t_nom":0.015},
}

def tag_material(obj, material="Al6061", density=None, alpha=None, epsilon=None, t_nom=None):
    # usa valores por defecto desde MATERIALS si no se pasan
    props = MATERIALS.get(material, {})
    rho = density if density is not None else props.get("rho", 2700.0)
    a   = alpha   if alpha   is not None else props.get("alpha", 0.2)
    e   = epsilon if epsilon is not None else props.get("eps", 0.8)
    t   = t_nom   if t_nom   is not None else props.get("t_nom", 0.002)

    if not hasattr(obj, "Material"):
        obj.addProperty("App::PropertyString", "Material", "FEM", "Material tag")
    if not hasattr(obj, "Density"):
        obj.addProperty("App::PropertyFloat", "Density", "FEM", "Density kg/m^3")
    if not hasattr(obj, "Alpha"):
        obj.addProperty("App::PropertyFloat", "Alpha", "Thermal", "Solar absorptivity")
    if not hasattr(obj, "Epsilon"):
        obj.addProperty("App::PropertyFloat", "Epsilon", "Thermal", "Emissivity")
    if not hasattr(obj, "t_nom"):
        obj.addProperty("App::PropertyFloat", "t_nom", "FEM", "Nominal shell thickness")
    obj.Material = material
    obj.Density = float(rho)
    obj.Alpha = float(a)
    obj.Epsilon = float(e)
    obj.t_nom = float(t)
    # flag imprimible si grosor nominal >= print_wall
    if t and t >= P.get("print_wall", 0.0):
        if not hasattr(obj, "Printable"):
            obj.addProperty("App::PropertyBool", "Printable", "Print", "Printable part")
        obj.Printable = True

def color(obj, rgb=(0.8,0.8,0.8)):
    try:
        obj.ViewObject.ShapeColor = rgb
    except Exception:
        pass

# -----------------------
# Robust boolean helpers
# -----------------------

def fuse_shapes_safe(base_shape, other_shape):
    try:
        return base_shape.fuse(other_shape)
    except Exception:
        try:
            bb1 = base_shape.BoundBox
            bb2 = other_shape.BoundBox
            cx = (bb1.XMin + bb1.XMax + bb2.XMin + bb2.XMax)/4.0
            cy = (bb1.YMin + bb1.YMax + bb2.YMin + bb2.YMax)/4.0
            cz = (bb1.ZMin + bb1.ZMax + bb2.ZMin + bb2.ZMax)/4.0
            overlap = Part.makeBox(max(0.01, (bb1.XLength+bb2.XLength)*0.08),
                                   max(0.01, (bb1.YLength+bb2.YLength)*0.08),
                                   max(0.01, (bb1.ZLength+bb2.ZLength)*0.08),
                                   Vector(cx-0.04, cy-0.04, cz-0.04))
            return base_shape.fuse(other_shape.fuse(overlap))
        except Exception:
            try:
                return base_shape.fuse(other_shape)
            except Exception:
                return base_shape

def try_make_solid(shape):
    try:
        if isinstance(shape, Part.Solid):
            return shape
        shell = Part.Shell(shape.Faces)
        solid = Part.Solid(shell)
        return solid
    except Exception:
        try:
            solids = [s for s in getattr(shape, "Solids", [])]
            if solids:
                comp = Part.Compound(solids)
                return comp
        except Exception:
            pass
    return shape

# -----------------------
# Helpers: primitives
# -----------------------

def make_cylinder(name, R, L, base=Vector(0,0,0)):
    shape = Part.makeCylinder(R, L, Vector(0,0,0), Vector(1,0,0))
    obj = doc.addObject("Part::Feature", name)
    obj.Shape = shape
    obj.Placement.Base = base
    return obj

def make_cone_truncated(name, R1, R2, L, base=Vector(0,0,0)):
    shape = Part.makeCone(R1, R2, L, Vector(0,0,0), Vector(1,0,0))
    obj = doc.addObject("Part::Feature", name)
    obj.Shape = shape
    obj.Placement.Base = base
    return obj

def make_box(name, X, Y, Z, base=Vector(0,0,0)):
    shape = Part.makeBox(X, Y, Z, Vector(0,0,0))
    obj = doc.addObject("Part::Feature", name)
    obj.Shape = shape
    obj.Placement.Base = base
    return obj

def make_sphere(name, R, center=Vector(0,0,0)):
    shape = Part.makeSphere(R, center)
    obj = doc.addObject("Part::Feature", name)
    obj.Shape = shape
    return obj

def make_annular_flange(name, R_inner, R_outer, t, base=Vector(0,0,0)):
    c_out = Part.makeCylinder(R_outer, t, Vector(0,0,0), Vector(1,0,0))
    c_in  = Part.makeCylinder(R_inner, t+1e-6, Vector(0,0,0), Vector(1,0,0))
    ring = c_out.cut(c_in)
    obj = doc.addObject("Part::Feature", name)
    obj.Shape = ring
    obj.Placement.Base = base
    return obj

def polar_bolt_circle(name_prefix, N, R_pcd, L, d, base=Vector(0,0,0)):
    bolts = []
    for i in range(N):
        theta = 2*math.pi*i/float(N)
        y = R_pcd*math.cos(theta)
        z = R_pcd*math.sin(theta)
        bolt = Part.makeCylinder(d/2.0, L, Vector(0,0,0), Vector(1,0,0))
        bolt_obj = doc.addObject("Part::Feature", f"{name_prefix}_{i+1:02d}")
        bolt_obj.Shape = bolt
        bolt_obj.Placement.Base = base.add(Vector(0, y, z))
        bolts.append(bolt_obj)
    return bolts

def make_tube(name, R_outer, t, L, base=Vector(0,0,0)):
    c_out = Part.makeCylinder(R_outer, L, Vector(0,0,0), Vector(1,0,0))
    c_in  = Part.makeCylinder(max(R_outer - t, 0.0), L+1e-6, Vector(0,0,0), Vector(1,0,0))
    tube = c_out.cut(c_in)
    obj = doc.addObject("Part::Feature", name)
    obj.Shape = tube
    obj.Placement.Base = base
    return obj

def make_paraboloid_dish(name, D, p, t=0.003, base=Vector(0,0,0)):
    R = D/2.0
    f = (D*D)/(16.0*p)
    pts = []
    N = 40
    for i in range(N+1):
        r = R * i/float(N)
        z = (r*r)/(4.0*f)
        pts.append(Vector(0, r, z))
    spline = Part.BSplineCurve()
    spline.interpolate(pts)
    edge = spline.toShape()
    axis = Vector(1,0,0)
    face_outer = Part.Wire([edge]).revolve(Vector(0,0,0), axis, 360)
    pts_in = []
    for i in range(N+1):
        r = R * i/float(N)
        z = (r*r)/(4.0*f) - t
        pts_in.append(Vector(0, r, max(z, 0.0)))
    spline_in = Part.BSplineCurve()
    spline_in.interpolate(pts_in)
    edge_in = spline_in.toShape()
    face_inner = Part.Wire([edge_in]).revolve(Vector(0,0,0), axis, 360)
    try:
        dish = face_outer.cut(face_inner)
    except Exception:
        dish = face_outer
    obj = doc.addObject("Part::Feature", name)
    obj.Shape = dish
    obj.Placement.Base = base
    return obj

# -----------------------
# Truss builder (A)
# -----------------------

def make_truss_bus(name, L_tr=2.2, W_tr=1.2, H_tr=1.0, b=0.08, h=0.08, d_cordon=0.06, base=Vector(0,0,0)):
    group = doc.addObject("App::DocumentObjectGroup", name)
    offs = [
        Vector(0, +W_tr/2.0, +H_tr/2.0),
        Vector(0, +W_tr/2.0, -H_tr/2.0),
        Vector(0, -W_tr/2.0, +H_tr/2.0),
        Vector(0, -W_tr/2.0, -H_tr/2.0),
    ]
    for i,o in enumerate(offs):
        tube = make_tube(f"{name}_Chord_{i+1}", d_cordon/2.0, t=d_cordon/10.0, L=L_tr, base=base.add(o))
        color(tube, (0.2,0.2,0.25))
        tag_material(tube, "Al6061")
        group.addObject(tube)
    nframes = int(L_tr/0.55)+1
    for k in range(nframes):
        xk = base.x + k*(L_tr/(nframes-1 if nframes>1 else 1))
        beam_top = make_box(f"{name}_FrameTop_{k}",  b, W_tr, b, base=Vector(xk, -W_tr/2.0,  H_tr/2.0 - b/2.0))
        beam_bot = make_box(f"{name}_FrameBot_{k}",  b, W_tr, b, base=Vector(xk, -W_tr/2.0, -H_tr/2.0 - b/2.0))
        beam_l   = make_box(f"{name}_FrameLeft_{k}", b, b, H_tr, base=Vector(xk, +W_tr/2.0 - b/2.0, -H_tr/2.0))
        beam_r   = make_box(f"{name}_FrameRight_{k}",b, b, H_tr, base=Vector(xk, -W_tr/2.0 - b/2.0, -H_tr/2.0))
        for be in [beam_top, beam_bot, beam_l, beam_r]:
            color(be, (0.35,0.35,0.4))
            tag_material(be, "CFRP")
            group.addObject(be)
    bay = 0.55
    ndiag = int(max(1, L_tr/bay))
    for j in range(ndiag):
        x0 = base.x + j*bay
        diag1 = Part.makeBox(b, bay, b, Vector(x0, +W_tr/2.0 - b/2.0, -H_tr/2.0 - b/2.0))
        d1_obj = doc.addObject("Part::Feature", f"{name}_Diag_{j}")
        d1_obj.Shape = diag1
        color(d1_obj, (0.4,0.4,0.45))
        tag_material(d1_obj, "CFRP")
        group.addObject(d1_obj)
    return group

# -----------------------
# Geometry parameters (ampliados)
# -----------------------

P = {
    # A. Bus
    "A_L_tr": 2.2, "A_b": 0.08, "A_h": 0.08, "A_W_tr": 1.2, "A_H_tr": 1.0, "A_cordon": 0.06,
    "A_Box": (1.2, 1.0, 0.8),
    "A_Tank": (0.45, 0.9),
    "A_Bolts": (48, 1.6, 0.014),  # N, PCD[m], bolt_d[m] approx
    # B. Solar
    "B_L": 7.0, "B_W": 2.0, "B_t": 0.02, "B_Mast": (0.15,0.25,1.2), "B_Hinge": (0.05,0.12),
    # C. Hab1
    "C_R": 1.60, "C_L": 3.5, "C_t": 0.003, "C_brida_PCD": 3.1, "C_brida_N": 72, "C_brida_t": 0.012,
    # D. Hab2
    "D_R": 1.60, "D_L": 2.2, "D_t": 0.003,
    # E. Tunnel
    "E_R": 1.0, "E_L": 1.0, "E_t": 0.002, "E_cone_L": 0.45, "E_R2": 1.60,
    # F. PTK
    "F_R1": 1.35, "F_R2": 2.10, "F_L": 1.7, "F_Rbase": 1.35, "F_Lbase": 0.6,
    # G. Orion
    "G_L_ogiva": 1.9, "G_Dmax": 3.1, "G_R_sm": 1.25, "G_L_sm": 1.1, "G_R_adapter1": 1.3, "G_R_adapter2": 1.0, "G_L_adapter": 0.4,
    # H. Logistics
    "H_R": 0.60, "H_L": 1.4, "H_Mast": (0.06,0.8),
    # I. Airlock
    "I_R": 0.85, "I_Rneck": 0.55, "I_Lneck": 0.5,
    # J. Antennas
    "J_Panel": (1.2, 0.8, 0.02), "J_HGA_D": 0.9, "J_HGA_p": 0.11, "J_Mast": (0.04,0.6),
    # K. Radiators
    "K_Panel": (1.6, 1.1, 0.015), "K_TubeR": 0.006,
    # L. Wires
    "L_Trunk": 0.0125, "L_Branch": 0.006,
    # extras para impresión y radiación
    "print_wall": 0.0025,       # grosor mínimo imprimible
    "mli_layers": 3,
    "mli_layer_t": 0.005,
    "whipple_disks": 4,
    "whipple_t": 0.02,
    # envolvente exterior / casco
    "fairing_extra": 0.15,      # tamaño para shell externo que dé forma
    "hull_shell_t": 0.008,      # grosor del cascaron imprimible (shell)
    "Gap": 0.08
}

# -----------------------
# Construcción (se reutiliza y amplía la estructura previa)
# -----------------------

x = 0.0
gap = P["Gap"]

# E. Tunnel (centro)
E_R = P["E_R"]; E_L = P["E_L"]; E_cone_L = P["E_cone_L"]; E_R2 = P["E_R2"]
x_E_start = - (E_cone_L + E_L + E_cone_L)/2.0
E_cone_L_obj = make_cone_truncated("E_ConeLeft", E_R2, E_R, E_cone_L, base=Vector(x_E_start,0,0))
E_cyl_obj   = make_cylinder("E_Cyl", E_R, E_L, base=Vector(x_E_start+E_cone_L,0,0))
E_cone_R_obj = make_cone_truncated("E_ConeRight", E_R, E_R2, E_cone_L, base=Vector(x_E_start+E_cone_L+E_L,0,0))
for eo in [E_cone_L_obj, E_cyl_obj, E_cone_R_obj]:
    color(eo, (0.75,0.75,0.78)); tag_material(eo, "Al2219", t_nom=P["E_t"])

# C. Hab1 left
C_R = P["C_R"]; C_L = P["C_L"]
x_C = x_E_start - gap - C_L
C_cyl = make_cylinder("C_Hab1", C_R, C_L, base=Vector(x_C,0,0))
color(C_cyl, (0.9,0.9,0.95)); tag_material(C_cyl, "CFRP", t_nom=max(P["C_t"], P["print_wall"]))
# brida y tornillos
C_brida = make_annular_flange("C_Flange_R", R_inner=E_R*0.98, R_outer=P["C_brida_PCD"]/2.0*0.5+E_R, t=P["C_brida_t"], base=Vector(x_E_start - P["C_brida_t"],0,0))
color(C_brida, (0.8,0.8,0.85)); tag_material(C_brida, "Al6061", t_nom=P["C_brida_t"])
Cb_N = P["C_brida_N"]; Cb_PCD = P["C_brida_PCD"]/2.0
_ = polar_bolt_circle("C_E_Bolt", N=Cb_N, R_pcd=Cb_PCD, L=0.02, d=0.014, base=Vector(x_E_start - 0.02, 0, 0))

# joiner C<->E (evita huecos)
join_CE = Part.makeCylinder(E_R*0.98, 0.04, Vector(x_E_start - 0.02, 0, 0), Vector(1,0,0))
join_CE_obj = doc.addObject("Part::Feature", "Joiner_C_E"); join_CE_obj.Shape = join_CE
tag_material(join_CE_obj, "Al6061", t_nom=0.02); color(join_CE_obj, (0.6,0.6,0.65))

# A. Bus left of C
A_L = P["A_L_tr"]; x_A = x_C - gap - A_L
A_truss = make_truss_bus("A_Bus", L_tr=A_L, W_tr=P["A_W_tr"], H_tr=P["A_H_tr"], d_cordon=P["A_cordon"], base=Vector(x_A,0,0))
bx, by, bz = P["A_Box"]
A_box = make_box("A_ElecBox", bx, by, bz, base=Vector(x_A + (A_L-bx)/2.0, -by/2.0, -bz/2.0))
color(A_box, (0.2,0.35,0.6)); tag_material(A_box, "Al6061", t_nom=max(0.003, P["print_wall"]))
tR, tL = P["A_Tank"]; A_tank = make_cylinder("A_Tank", tR, tL, base=Vector(x_A + 0.2, 0, -tR))
color(A_tank, (0.85,0.85,0.9)); tag_material(A_tank, "Al2219", t_nom=0.005)

# thrusters
N_thr = 6; thr_R = 0.06; thr_L = 0.18; PCD_thr = 0.5
for i in range(N_thr):
    th = 2*math.pi*i/N_thr
    y = PCD_thr*math.cos(th); z = PCD_thr*math.sin(th)
    thr = make_cylinder(f"A_Thr_{i+1}", thr_R, thr_L, base=Vector(x_A + 0.2 + tL + 0.05, y, z - thr_R))
    color(thr, (0.5,0.5,0.55)); tag_material(thr, "Ti", t_nom=0.006)

# Solar arrays (thickened printable)
BL, BW, Bt = P["B_L"], P["B_W"], P["B_t"]
B_left = make_box("B_Left", BL, Bt + max(P["print_wall"], 0.002), BW, base=Vector(x_A + 0.3, -Bt/2.0, P["A_H_tr"]/2.0 + 0.05))
color(B_left, (0.1,0.1,0.2)); tag_material(B_left, "Panel_CFRP", t_nom=max(Bt, P["print_wall"]))
B_right = make_box("B_Right", BL, Bt + max(P["print_wall"], 0.002), BW, base=Vector(x_A + 0.3, -Bt/2.0, -P["A_H_tr"]/2.0 - BW - 0.05))
color(B_right, (0.1,0.1,0.2)); tag_material(B_right, "Panel_CFRP", t_nom=max(Bt, P["print_wall"]))

# D. Hab2 right
D_R = P["D_R"]; D_L = P["D_L"]; x_D = x_E_start + E_cone_L + E_L + E_cone_L + gap
D_cyl = make_cylinder("D_Hab2", D_R, D_L, base=Vector(x_D,0,0))
color(D_cyl, (0.92,0.92,0.96)); tag_material(D_cyl, "CFRP", t_nom=max(P["D_t"], P["print_wall"]))
D_brida = make_annular_flange("D_Flange_L", R_inner=E_R*0.98, R_outer=(P["C_brida_PCD"]/2.0)*0.5+E_R, t=P["C_brida_t"], base=Vector(x_E_start + E_cone_L + E_L + E_cone_L,0,0))
color(D_brida, (0.8,0.8,0.85)); tag_material(D_brida, "Al6061", t_nom=P["C_brida_t"])
join_DE = Part.makeCylinder(E_R*0.98, 0.04, Vector(x_E_start + E_cone_L + E_L - 0.02, 0, 0), Vector(1,0,0))
join_DE_obj = doc.addObject("Part::Feature", "Joiner_D_E"); join_DE_obj.Shape = join_DE
tag_material(join_DE_obj, "Al6061", t_nom=0.02); color(join_DE_obj, (0.6,0.6,0.65))

# G. Orion
G_adapter = make_cone_truncated("G_Adapter", P["G_R_adapter1"], P["G_R_adapter2"], P["G_L_adapter"], base=Vector(x_D + D_L + gap,0,0))
color(G_adapter, (0.75,0.78,0.8)); tag_material(G_adapter, "AlTi", t_nom=0.006)
G_sm = make_cylinder("G_SM", P["G_R_sm"], P["G_L_sm"], base=Vector(G_adapter.Placement.Base.x + P["G_L_adapter"],0,0))
color(G_sm, (0.7,0.72,0.76)); tag_material(G_sm, "Al2219", t_nom=0.004)
G_Rmax = P["G_Dmax"]/2.0
G_cone = make_cone_truncated("G_Cone", P["G_R_adapter2"], G_Rmax, P["G_L_ogiva"]*0.7, base=Vector(G_sm.Placement.Base.x + P["G_L_sm"],0,0))
G_cap  = make_cylinder("G_Cap", G_Rmax, P["G_L_ogiva"]*0.3, base=Vector(G_cone.Placement.Base.x + G_cone.Shape.BoundBox.XLength,0,0))
for go in [G_cone, G_cap]:
    color(go, (0.6,0.62,0.66)); tag_material(go, "TPS_Composite", t_nom=0.01)

# F. PTK
F_neck_R = 1.05; F_neck_L = 0.35; x_F = x_C + C_L*0.6
F_neck = make_cylinder("F_Neck", F_neck_R, F_neck_L, base=Vector(x_F, C_R + F_neck_R*0.1, 0))
F_cone = make_cone_truncated("F_Cone", P["F_R1"], P["F_R2"], P["F_L"], base=Vector(x_F + F_neck_L, C_R + F_neck_R*0.1, 0))
F_base = make_cylinder("F_Base", P["F_Rbase"], P["F_Lbase"], base=Vector(F_cone.Placement.Base.x + P["F_L"], C_R + F_neck_R*0.1, 0))
for fo in [F_neck, F_cone, F_base]:
    color(fo, (0.55,0.57,0.6)); tag_material(fo, "Ti_Al", t_nom=0.01)

# H. Logistics
H_R = P["H_R"]; H_L = P["H_L"]
H_cyl = make_cylinder("H_Log", H_R, H_L, base=Vector(x_E_start + E_cone_L + E_L/2.0 - H_L/2.0, 0, -E_R - H_R - 0.2))
color(H_cyl, (0.75,0.77,0.8)); tag_material(H_cyl, "Al6061", t_nom=0.004)
H_mast = make_cylinder("H_AntennaMast", P["H_Mast"][0]/2.0, P["H_Mast"][1], base=Vector(H_cyl.Placement.Base.x + H_L + 0.05, 0, H_cyl.Placement.Base.z - P["H_Mast"][0]/2.0))
color(H_mast, (0.2,0.2,0.25)); tag_material(H_mast, "CFRP", t_nom=0.003)

# I. Airlock
I_sph = make_sphere("I_Sphere", P["I_R"], center=Vector(x_E_start + E_cone_L + E_L*0.2, E_R + P["I_R"] + 0.15, 0))
color(I_sph, (0.88,0.9,0.95)); tag_material(I_sph, "Ti_Al", t_nom=0.003)
I_neck = make_cylinder("I_Neck", P["I_Rneck"], P["I_Lneck"], base=Vector(x_E_start + E_cone_L + E_L*0.2 - P["I_Lneck"], E_R + 0.15, 0))
color(I_neck, (0.85,0.87,0.92)); tag_material(I_neck, "Al2219", t_nom=0.003)
for i in range(4):
    dz = (-0.3 + 0.2*i)
    bracket = make_box(f"I_Bracket_{i+1}", 0.25, 0.05, 0.12, base=Vector(I_neck.Placement.Base.x + 0.02, E_R + 0.12, dz))
    color(bracket, (0.7,0.7,0.75)); tag_material(bracket, "Al6061", t_nom=0.006)

# J. Antennas & HGA
for side, sgn in [("J_Panel_L", +1), ("J_Panel_R", -1)]:
    px, py, pz = P["J_Panel"]
    pan = make_box(side, px, py + max(P["print_wall"], 0.002), pz, base=Vector(x_C + C_L*0.4, sgn*(C_R + 0.2), -pz/2.0))
    color(pan, (0.95,0.85,0.2)); tag_material(pan, "Panel_Antenna", t_nom=max(py, P["print_wall"]))
    mast = make_cylinder(f"{side}_Mast", P["J_Mast"][0]/2.0, P["J_Mast"][1], base=Vector(x_C + C_L*0.4 - 0.1, sgn*(C_R + 0.2), -P["J_Mast"][0]/2.0))
    color(mast, (0.25,0.25,0.3)); tag_material(mast, "CFRP", t_nom=0.003)

J_dish = make_paraboloid_dish("J_HGA_Dish", P["J_HGA_D"], P["J_HGA_p"], t=max(0.003, P["print_wall"]), base=Vector(x_E_start + E_cone_L + E_L*0.6, -(E_R + 0.6), 0))
color(J_dish, (0.95,0.95,0.95)); tag_material(J_dish, "Al_Coated", t_nom=max(0.003, P["print_wall"]))
J_mast = make_cylinder("J_HGA_Mast", P["J_Mast"][0]/2.0, P["J_Mast"][1], base=Vector(J_dish.Placement.Base.x - 0.1, -(E_R + 0.6), -P["J_Mast"][0]/2.0))
color(J_mast, (0.25,0.25,0.3)); tag_material(J_mast, "CFRP", t_nom=0.003)

# K. Radiators
kx, ky, kz = P["K_Panel"]
K1 = make_box("K_Rad_C", kx, ky + max(P["print_wall"], 0.002), kz, base=Vector(x_C + 0.6, C_R + 0.05, -kz/2.0))
K2 = make_box("K_Rad_D", kx, ky + max(P["print_wall"], 0.002), kz, base=Vector(x_D + 0.4, -(D_R + 0.05) - ky, -kz/2.0))
for k in [K1, K2]:
    color(k, (0.9,0.9,0.95)); tag_material(k, "Radiator", t_nom=max(kz, P["print_wall"]))
for baseX in [K1.Placement.Base.x + kx/2.0, K2.Placement.Base.x + kx/2.0]:
    tube = make_cylinder("K_Loop", P["K_TubeR"], 1.2, base=Vector(baseX, 0.0, -P["K_TubeR"]))
    color(tube, (0.8,0.8,0.85)); tag_material(tube, "CoolantTube", t_nom=0.002)

# L. Harness
for idx, zsgn in enumerate([+1, -1]):
    L_len = (x_D + D_L + P["G_L_ogiva"] + 2.0) - (x_A - 0.5)
    wire = make_cylinder(f"L_Trunk_{idx+1}", P["L_Trunk"], L_len, base=Vector(x_A - 0.5, +C_R + 0.3, zsgn*(C_R + 0.3)))
    color(wire, (0.2,0.2,0.2)); tag_material(wire, "Harness", t_nom=0.01)

# -----------------------
# Bolt circles & holes
# -----------------------

EC_N   = P["C_brida_N"]; EC_PCD = P["C_brida_PCD"] / 2.0; EC_x = x_E_start
EC_bolts = polar_bolt_circle("Bolt_EC", N=EC_N, R_pcd=EC_PCD, L=0.02, d=0.014, base=Vector(EC_x - 0.01, 0, 0))
for b in EC_bolts: color(b, (0.35, 0.35, 0.35)); tag_material(b, "Bolt_Steel", t_nom=0.014)
try:
    fused = EC_bolts[0].Shape
    for bb in EC_bolts[1:]:
        fused = fused.fuse(bb.Shape)
    C_brida.Shape = C_brida.Shape.cut(fused)
except Exception:
    pass

ED_N   = P["C_brida_N"]; ED_PCD = P["C_brida_PCD"] / 2.0; ED_x = x_E_start + E_cone_L + E_L + E_cone_L
ED_bolts = polar_bolt_circle("Bolt_ED", N=ED_N, R_pcd=ED_PCD, L=0.02, d=0.014, base=Vector(ED_x + 0.01, 0, 0))
for b in ED_bolts: color(b, (0.35, 0.35, 0.35)); tag_material(b, "Bolt_Steel", t_nom=0.014)
try:
    fused = ED_bolts[0].Shape
    for bb in ED_bolts[1:]:
        fused = fused.fuse(bb.Shape)
    D_brida.Shape = D_brida.Shape.cut(fused)
except Exception:
    pass

A_N, A_PCD_diam, A_bolt_d = P["A_Bolts"]; A_PCD = A_PCD_diam / 2.0
AC_x  = x_C - P["C_brida_t"] - 0.02
A_flange = make_annular_flange("A_Flange_C", R_inner=A_PCD - 0.06, R_outer=A_PCD + 0.06, t=P["C_brida_t"], base=Vector(AC_x, 0, 0))
color(A_flange, (0.8, 0.8, 0.85)); tag_material(A_flange, "Al6061", t_nom=0.012)
AC_bolts = polar_bolt_circle("Bolt_AC", N=A_N, R_pcd=A_PCD, L=0.02, d=A_bolt_d, base=Vector(AC_x - 0.005, 0, 0))
for b in AC_bolts: color(b, (0.35, 0.35, 0.35)); tag_material(b, "Bolt_Steel", t_nom=A_bolt_d)

# Dock/adapters rings (F, G, H, I)
F_ring_R = 2.1 / 2.0; F_ring_x = F_base.Placement.Base.x + 0.02
F_ring = make_annular_flange("F_Dock_Ring", R_inner=F_ring_R - 0.06, R_outer=F_ring_R + 0.06, t=0.012, base=Vector(F_ring_x, F_base.Placement.Base.y, F_base.Placement.Base.z))
color(F_ring, (0.78, 0.78, 0.82)); tag_material(F_ring, "Ti_Al", t_nom=0.012)
F_bolts = polar_bolt_circle("Bolt_F_Dock", N=60, R_pcd=F_ring_R, L=0.02, d=0.014, base=Vector(F_ring_x, F_base.Placement.Base.y, F_base.Placement.Base.z))
for b in F_bolts: color(b, (0.35,0.35,0.35)); tag_material(b, "Bolt_Steel", t_nom=0.014)

G_ring_R = 2.6 / 2.0; G_ring_x = G_adapter.Placement.Base.x - 0.01
G_ring = make_annular_flange("G_Adapter_Ring", R_inner=G_ring_R - 0.07, R_outer=G_ring_R + 0.07, t=0.012, base=Vector(G_ring_x, 0, 0))
color(G_ring, (0.78,0.8,0.82)); tag_material(G_ring, "AlTi", t_nom=0.012)
G_bolts = polar_bolt_circle("Bolt_G_Adapt", N=80, R_pcd=G_ring_R, L=0.02, d=0.014, base=Vector(G_ring_x - 0.005, 0, 0))
for b in G_bolts: color(b, (0.35,0.35,0.35)); tag_material(b, "Bolt_Steel", t_nom=0.014)

H_coll_R = 1.2 / 2.0
H_ring = make_annular_flange("H_Collar", R_inner=H_coll_R - 0.05, R_outer=H_coll_R + 0.05, t=0.010, base=Vector(H_cyl.Placement.Base.x + H_L*0.5, 0, H_cyl.Placement.Base.z + H_R + 0.02))
color(H_ring, (0.8, 0.8, 0.85)); tag_material(H_ring, "Al6061", t_nom=0.010)
H_bolts = polar_bolt_circle("Bolt_H_Collar", N=36, R_pcd=H_coll_R, L=0.02, d=0.012, base=Vector(H_ring.Placement.Base.x, H_ring.Placement.Base.y, H_ring.Placement.Base.z))
for b in H_bolts: color(b, (0.35,0.35,0.35)); tag_material(b, "Bolt_Steel", t_nom=0.012)

I_PCD_R = 1.1 / 2.0
I_ring = make_annular_flange("I_Collar", R_inner=I_PCD_R - 0.05, R_outer=I_PCD_R + 0.05, t=0.010, base=Vector(I_neck.Placement.Base.x + P["I_Lneck"] - 0.005, I_neck.Placement.Base.y, I_neck.Placement.Base.z))
color(I_ring, (0.82,0.84,0.88)); tag_material(I_ring, "Al2219", t_nom=0.010)
I_bolts = polar_bolt_circle("Bolt_I_Collar", N=32, R_pcd=I_PCD_R, L=0.02, d=0.012, base=Vector(I_ring.Placement.Base.x, I_ring.Placement.Base.y, I_ring.Placement.Base.z))
for b in I_bolts: color(b, (0.35,0.35,0.35)); tag_material(b, "Bolt_Steel", t_nom=0.012)

# -----------------------
# MLI multi-layer + Whipple protection
# -----------------------

mli_layers = []; mlibase_r = E_R + 0.06
for i in range(P["mli_layers"]):
    t = P["mli_layer_t"]
    r_out = mlibase_r + i*(t + 0.004)
    cyl_o = Part.makeCylinder(r_out + t, E_L + 0.06, Vector(0,0,0), Vector(1,0,0))
    cyl_i = Part.makeCylinder(r_out, E_L + 0.08, Vector(0,0,0), Vector(1,0,0))
    layer = cyl_o.cut(cyl_i)
    layer.Placement = App.Placement(Vector(x_E_start+E_cone_L,0,0), App.Rotation())
    mli_layers.append(layer)
if mli_layers:
    mli_union = mli_layers[0]
    for l in mli_layers[1:]:
        mli_union = mli_union.fuse(l)
    mli_obj = doc.addObject("Part::Feature", "MLI_Layers"); mli_obj.Shape = mli_union
    tag_material(mli_obj, "MLI", t_nom=P["mli_layer_t"]); color(mli_obj, (0.96,0.92,0.8))

# whipple
whip_disks = []
for i in range(P["whipple_disks"]):
    dr = G_Rmax + 0.15 + i*0.03
    disk = Part.makeCylinder(dr, P["whipple_t"], Vector(G_adapter.Placement.Base.x - 0.3 - i*0.08, 0, 0), Vector(1,0,0))
    disk_obj = doc.addObject("Part::Feature", f"Whipple_{i+1}"); disk_obj.Shape = disk
    tag_material(disk_obj, "Aluminum_Alloy", t_nom=P["whipple_t"]); color(disk_obj, (0.75,0.72,0.65))
    whip_disks.append(disk_obj)

# -----------------------
# Envolvente exterior (fairing) y cascarón hull imprimible
# -----------------------

# Crear una envolvente suave que cubra C - E - D y parte de G para dar forma
try:
    # bound extremes along X
    xmin = min(o.Shape.BoundBox.XMin for o in [C_cyl, E_cyl_obj, D_cyl])
    xmax = max(o.Shape.BoundBox.XMax for o in [C_cyl, E_cyl_obj, D_cyl, G_sm])
    length = xmax - xmin + P["fairing_extra"]
    # fairing como cilindro escalonado/cone blend: para forma "guay" hacemos un loft de 3 secciones
    r1 = C_R + 0.04 + P["fairing_extra"]
    r2 = E_R + 0.06 + P["fairing_extra"]
    r3 = G_Rmax + 0.12 + P["fairing_extra"]
    sec1 = Part.makeCircle(r1, App.Vector(xmin + 0.02,0,0), App.Vector(1,0,0))
    sec2 = Part.makeCircle(r2, App.Vector(xmin + (length)/2.0,0,0), App.Vector(1,0,0))
    sec3 = Part.makeCircle(r3, App.Vector(xmax - 0.02,0,0), App.Vector(1,0,0))
    fair = Part.makeLoft([sec1, sec2, sec3], True)
    fair_obj = doc.addObject("Part::Feature", "Fairing_External"); fair_obj.Shape = fair
    tag_material(fair_obj, "UltraAlloy", t_nom=P["hull_shell_t"]); color(fair_obj, (0.42,0.46,0.52))
    # cascarón: generar shell espesor restando inner slightly smaller
    fair_outer = fair
    fair_inner_cut = fair_outer.makeScaled(1.0 - P["hull_shell_t"]/max(r2,0.1))
    # fallback si makeScaled no existe: crear inner cylinder approximation
    try:
        inner = fair_inner_cut
        shell_shape = fair_outer.cut(inner)
    except Exception:
        inner_cyl = Part.makeCylinder(r2 - P["hull_shell_t"], length + 0.1, Vector(xmin + 0.02,0,0), Vector(1,0,0))
        shell_shape = fair_outer.cut(inner_cyl)
    hull_shell_obj = doc.addObject("Part::Feature", "Hull_Shell"); hull_shell_obj.Shape = shell_shape
    tag_material(hull_shell_obj, "UltraAlloy", t_nom=P["hull_shell_t"]); color(hull_shell_obj, (0.36,0.4,0.46))
except Exception:
    pass

# -----------------------
# Compartimentos internos / bulkheads / decks (funcionalidad interna)
# -----------------------

internal_parts = []
def make_bulkhead(xpos, R, t=0.02, label="Bulkhead"):
    disc = Part.makeCylinder(R, t, Vector(xpos,0,0), Vector(1,0,0))
    o = doc.addObject("Part::Feature", f"{label}_{round(xpos,3)}")
    o.Shape = disc
    tag_material(o, "UltraAlloy", t_nom=t); color(o, (0.5,0.48,0.46))
    internal_parts.append(o)
    return o

# crear bulkheads en interfaces (entre C/E, E/D, D/G etc.)
bh1 = make_bulkhead(x_E_start - 0.02, E_R*0.98, t=0.03, label="Bulkhead_CE")
bh2 = make_bulkhead(x_E_start + E_cone_L + E_L - 0.02, E_R*0.98, t=0.03, label="Bulkhead_ED")
bh3 = make_bulkhead(G_sm.Placement.Base.x + 0.05, G_Rmax*0.98, t=0.04, label="Bulkhead_G")

# internal deck floors inside bus A (simple trays)
tray = make_box("A_InnerTray", bx*0.9, by*0.9, 0.04, base=Vector(x_A + (A_L-bx*0.9)/2.0, -by*0.45, -0.02))
color(tray, (0.55,0.55,0.6)); tag_material(tray, "Al6061", t_nom=0.04)
internal_parts.append(tray)

# stringers (simplificados) along X under the tray
stringer = make_box("Stringer_Main", A_L*0.95, 0.03, 0.06, base=Vector(x_A + 0.02, -0.02, -0.15))
color(stringer, (0.45,0.45,0.5)); tag_material(stringer, "UltraAlloy", t_nom=0.03)
internal_parts.append(stringer)

# -----------------------
# Cálculo de volúmenes internos por subsystem
# -----------------------

def compute_subsystem_volumes():
    subs = {}
    groups = {
        "Hab_C": [C_cyl, C_brida],
        "Tunnel_E": [E_cyl_obj, E_cone_L_obj, E_cone_R_obj],
        "Hab_D": [D_cyl, D_brida],
        "Bus_A": [A_box, A_tank, A_truss],
        "Orion_G": [G_sm, G_cone, G_cap],
    }
    for name, items in groups.items():
        vol = 0.0
        for it in items:
            try:
                vol += float(it.Shape.Volume)
            except Exception:
                pass
        subs[name] = vol
    return subs

sub_vols = compute_subsystem_volumes()

# imprimir volúmenes
print("=== Volúmenes por subsistema (m^3) ===")
for k,v in sub_vols.items():
    print(f"{k}: {v:0.4f}")

# -----------------------
# Malla / hints / printable flags
# -----------------------

def set_mesh_hint(obj, h):
    if not hasattr(obj, "MeshSizeHint"):
        obj.addProperty("App::PropertyFloat", "MeshSizeHint", "Mesh", "Target mesh edge length")
    obj.MeshSizeHint = float(h)

core_objs = [C_cyl, D_cyl, E_cyl_obj, E_cone_L_obj, E_cone_R_obj, G_cone, G_cap, F_cone, F_base, F_neck, I_sph, I_neck]
for o in core_objs:
    set_mesh_hint(o, 0.12)
for o in [C_brida, D_brida, A_flange, F_ring, G_ring, H_ring, I_ring]:
    try: set_mesh_hint(o, 0.04)
    except: pass
for o in [B_left, B_right, K1, K2]:
    try: set_mesh_hint(o, 0.18)
    except: pass
for o in A_truss.Group:
    try: set_mesh_hint(o, 0.12)
    except: pass

# -----------------------
# Informe rápido de volúmenes y masas por objeto y totales
# -----------------------

def obj_mass(obj):
    try:
        vol = obj.Shape.Volume
        rho = getattr(obj, "Density", 0.0)
        return vol, vol * rho
    except Exception:
        return 0.0, 0.0

total_vol = 0.0; total_mass = 0.0
per_obj = []
for o in doc.Objects:
    if hasattr(o, "Shape") and not o.isDerivedFrom("App::DocumentObjectGroup"):
        v, m = obj_mass(o)
        total_vol += v; total_mass += m
        per_obj.append((o.Name, v, m))
print("=== Informe detallado (parte, vol[m3], masa[kg]) ===")
for n,v,m in sorted(per_obj, key=lambda x: -x[1])[:20]:
    print(f"{n:25s} {v:8.4f} m3   {m:8.1f} kg")
print("=== Totales ===")
print(f"Volumen total: {total_vol:0.4f} m^3")
print(f"Masa estimada: {total_mass:0.1f} kg")

# -----------------------
# Export STEP + STL por subconjuntos imprimibles
# -----------------------

try:
    import ImportGui as IG; export_mod = "ImportGui"
except Exception:
    try: import Import as IG; export_mod = "Import"
    except Exception: IG = None; export_mod = None

App.ActiveDocument.recompute()
objs_to_export = [o for o in doc.Objects if hasattr(o, "Shape") and not o.isDerivedFrom("App::DocumentObjectGroup")]
out_dir = App.getUserAppDataDir()
step_path = out_dir + "satellite_parametric_enhanced.step"
if IG:
    try:
        IG.export(objs_to_export, step_path); print(f"STEP exportado: {step_path}")
    except Exception:
        print("Error exportando STEP.")
else:
    print("No se pudo cargar módulo STEP; exporta desde GUI si es necesario.")

# Export STL para impresión: por objetos marcados 'Printable'
stl_dir = out_dir
for o in doc.Objects:
    if hasattr(o, "Printable") and getattr(o, "Printable"):
        try:
            fname = f"{stl_dir}{o.Name}.stl"
            mesh = MeshPart.meshFromShape(Shape=o.Shape, LinearDeflection=0.002, AngularDeflection=0.174)
            # escribir mesh si se generó
            if mesh:
                mesh.write(fname)
                print(f"STL exportado: {fname}")
        except Exception:
            pass

print("Macro mejorado cargado: materiales ultradurables, casco imprimible, compartimentos y volúmenes.")
doc.recompute()